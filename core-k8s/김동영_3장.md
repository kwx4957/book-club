## 3장
리눅스의 기본 요소들로 k8s 어떻게 구성하는지에 대해 이야기한다.

리눅스 기본 요소를 아는 것이 중요한 이유 `플러그인과 추가 기능` 모두가 동일한 기본 빌딩 블록들을 기반으로 하기 떄문이다. network는 `iptables`를 스토리지는 `nsenter`를 사용한다.

`unshare`와 `mount` 같은 컨테이너 런타임 명령어는 격리된 프로세스 생성할 때 사용된다.
컨테이너를 만드는 기술에 의해 실행되어야 할때가 많다. 중요한 보안 경계가 된다

> 리눅스의 철학인 `모든 것은 파일이다`와 연관된다.

파드를 생성할 때 격리, 네트워킹, 프로세스 관리의 구현 기능에 의존한다.  
- swapoff: cpu와 메모리 설정을 존중하는 방식으로 쿠버네티스를 실행하기 위한 전제 조건인 메모리 스와핑을 비활성화하는 명령
- iptables: 네트워크 프록시에 대한 핵심 요구사항으로 파드로 보내는 iptabels 규칙을 생성한다.
- mount: 경로의 특정 위치에 리소스를 연결한다.
- systemd: 클러스터에서 모든 컨테이너를 관리하기 위해 실행되는 핵심 프로세스인 kubelet을 시작한다.
- socat: 프로세스 사이의 양방향 정보 스트림을 설정할 수 있다. socat는 kubectl portfoward 명령이 동작하는데 필수적인 사항이다.
- nsenter: (네트워킹, 스토리지 또는 프로세스 측면에서) 프로세스의 다양한 네임스페이스로 들어가 진행 상태를 확인할 수 있는 도구이다. 파이썬의 네임스페이스가 로컬 이름을 갖는 특정 모듈을 갖고 잇느 것과 같이 리눅스 네임스페이스는 외부에서 로컬로 주소를 지정할수 없는 특정한 리소스를 갖는다. 예로, k8s 클러스에 있는 파드의 고유 IP 주소는 다른 파드와 공유되지 않는다. (일반적으로) 동일한 노드에서도 별도의 네임스페이스에서 실행되기 떄문이다.
- unshare: 프로세스가 네트워크, 마운트 또는 PID 관점에서 실행되는 하위 프로세스를 만들 수 있게 하는 명령이다. 유명한 컨테이너의 PID 1 현상. k8s 클러스의 모든 컨테이너가 자신을 전 세계에 있는 유일의 프로그램이라고 생각하는 문제에 대해 살펴본다. unshare는 마운트(/ 위치)와 네트워크 네임스페이스(IP 주소)를 격리할 수 있으며, 따라서 원시 리눅스 OS에 존재하는 docker run과 유사한 명령이다. 
- ps: kubelet은 프로세스가 언제 종료되었는지 확인하기 위해 계속 모니터링해야 한다. 


### kubelet의 파드 실행 과정
kubelet의 파드의 생명주기를 관장하는 제어 루프는 `프랙탈 방식`으로 동작한다. 

1. 프로그램이 실행되기 위한(cpu, 메모리, 네임스페이스 제한을 갖는) 격리된 홈 생성
2. 이더넷 연결 확인
3. dns을 확인하거나 스토리지에 액세스하기 위한 기본 파일에 대한 액세스 권한을 프로그램에 부여
4. 프로그롬이 종료되는 것을 대기
5. 프로그램이 사용할 공간과 자원을 정리
6. 프로그램에게 다른 파드로 이동해서 시작하는 것이 안전하다고 알려준다

k8s에 파드에 제공하는 것
파드에 제공하는 필드 중 하나는 `default-token` 볼륨이며 
- api 서버와 통신하기 위한 `폰 홈` 인증서 제공
- dns 정보 베공

### 네트워킹 문제
> 네트워크 프록시의 목적은 k8s 클러스터의 모든 노드가 트래픽을 k8s 서비스로 전달할 수 있도록 간단한 규칙들을 지속적으로 업데이트하고 관리하기 위한 것.

서비스가 파드에 라우팅 과정  
k8s 서비스 네트워킹 규칙은 iptables를 사용해 저수준 네트워킹 라우팅을 수행하는 kube-proxy에 의해 완전하게 구현된다.

iptables 프로그램이 커널에 규칙을 추가하며, 그러한 규칙들은 네트워크 트래픽을 처리하기 위해 제공된다. 

> 기본적인 파드 네트워킹에는 iptabels가 필요하지 않다. CNI이가 이를 처리한다. 

kube-dns 파드 전달 과정   
kube-dns는 서비스, Coredns는 kube-dns 서비스 엔드포인트를 구현한 파드이다. iptables에게 service에 액세스하려는 무언가가 있다면 그것을 규칙으로 보내라고 알려주는 규칙에 따라 dns 파드에게 라우팅된다.

```text
-A kube-svc-tet -m comment --comment
                "kube-system/kube-dns:dns-tcp"
                -j kube-sep-1234
```

엔드포인트 규칙을 사용해 개별 포트에 대한 규칙 정의  
서비스로부터 트래픽이 수신되면 kube-sep-1234에 맞는 규칙을 사용해 라우팅한다. 

```
-A kube-sep-1234 -s 10.244.0.2/32
                 -j kube-mark-masq
-A kube-sep-1234 -p tcp
                 -m tcp -j DNAT --to-destination 10.244.0.2:53
```

목적지 포트가 명확하지 않은 경우 이러한 IP 주소로 향한 모든 트래픽에 대한 마지막 목적지는 53번 포트가 된다. 이것이 kube-dns 파드 서비스가 트래픽을 처리하는 엔드포인트이다.   

파드 중 하나가 비정상이라면 kube-sep-1234에 대한 특정 규칙이 네트워크 프록시 kube-proxy에 의해 조정된다. 따라서 dns 파드의 정상적인 복사본만 트래픽이 전달된다. 

